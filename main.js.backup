import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';
import GUI from 'lil-gui';

// Cena
const scene = new THREE.Scene();

// Fog - Neblina para adicionar atmosfera
scene.fog = new THREE.FogExp2(0x87ceeb, 0.015); // Cor azul claro, densidade baixa

// C√¢mera
const camera = new THREE.PerspectiveCamera(
    75, // Campo de vis√£o
    window.innerWidth / window.innerHeight, // Aspect ratio
    0.1, // Near plane
    1000 // Far plane
);
camera.position.set(5, 5, 5);
camera.lookAt(0, 0, 0);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// OrbitControls - para controlar a c√¢mera com mouse
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; // Suaviza o movimento
controls.dampingFactor = 0.05;
controls.minDistance = 2;
controls.maxDistance = 50;

// Ilumina√ß√£o
const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
scene.add(ambientLight);

// Luz de Hemisf√©rio (ilumina de cima para baixo com cores diferentes)
const hemisphereLight = new THREE.HemisphereLight(
    0x87ceeb, // Cor do c√©u (azul claro)
    0x4a7c59, // Cor do solo (verde grama)
    0.3 // Intensidade inicial baixa para destacar as luzes pontuais
);
hemisphereLight.position.set(0, 50, 0);
scene.add(hemisphereLight);

// ============================================
// T√âCNICA: SpotLights - Show de Luzes
// Holofotes coloridos que iluminam a igreja
// ============================================

const lights = [];
const lightHelpers = [];
const spotTargets = []; // Alvos para os spotlights

// Configura√ß√µes do show de luzes
const lightShowConfig = {
    enabled: true,
    speed: 1.0,
    colorSpeed: 0.5,
    movementEnabled: true,
    colorChangeEnabled: true
};

// Cores do show de luzes (RGB vibrantes)
const showColors = [
    new THREE.Color(0xff0066), // Rosa
    new THREE.Color(0x00ff66), // Verde
    new THREE.Color(0x6600ff), // Roxo
    new THREE.Color(0xff6600), // Laranja
    new THREE.Color(0x00ffff), // Ciano
    new THREE.Color(0xffff00), // Amarelo
    new THREE.Color(0xff00ff), // Magenta
    new THREE.Color(0x0066ff)  // Azul
];

// Cria target para os spotlights (ponto que a luz aponta)
const churchTarget = new THREE.Object3D();
churchTarget.position.set(0, 2, 0); // Centro da igreja
scene.add(churchTarget);

// Spotlight 1 - Frontal Esquerda (Rosa/Magenta)
const spot1 = new THREE.SpotLight(0xff0066, 50, 50, Math.PI / 6, 0.5, 1);
spot1.position.set(-8, 10, 8);
spot1.target = churchTarget;
spot1.castShadow = true;
spot1.shadow.mapSize.width = 2048;
spot1.shadow.mapSize.height = 2048;
scene.add(spot1);
lights.push({
    name: 'Holofote 1 (Frontal Esq)',
    light: spot1,
    color: 0xff0066,
    baseAngle: 0,
    colorIndex: 0
});

// Spotlight 2 - Frontal Direita (Verde/Ciano)
const spot2 = new THREE.SpotLight(0x00ff66, 50, 50, Math.PI / 6, 0.5, 1);
spot2.position.set(8, 10, 8);
spot2.target = churchTarget;
spot2.castShadow = true;
scene.add(spot2);
lights.push({
    name: 'Holofote 2 (Frontal Dir)',
    light: spot2,
    color: 0x00ff66,
    baseAngle: Math.PI / 2,
    colorIndex: 2
});

// Spotlight 3 - Traseira Esquerda (Roxo/Azul)
const spot3 = new THREE.SpotLight(0x6600ff, 50, 50, Math.PI / 6, 0.5, 1);
spot3.position.set(-8, 10, -8);
spot3.target = churchTarget;
spot3.castShadow = true;
scene.add(spot3);
lights.push({
    name: 'Holofote 3 (Traseira Esq)',
    light: spot3,
    color: 0x6600ff,
    baseAngle: Math.PI,
    colorIndex: 4
});

// Spotlight 4 - Traseira Direita (Laranja/Amarelo)
const spot4 = new THREE.SpotLight(0xff6600, 50, 50, Math.PI / 6, 0.5, 1);
spot4.position.set(8, 10, -8);
spot4.target = churchTarget;
spot4.castShadow = true;
scene.add(spot4);
lights.push({
    name: 'Holofote 4 (Traseira Dir)',
    light: spot4,
    color: 0xff6600,
    baseAngle: Math.PI * 1.5,
    colorIndex: 6
});

// Spotlight 5 - Topo (Branco/Multi)
const spot5 = new THREE.SpotLight(0xffffff, 30, 60, Math.PI / 4, 0.3, 1);
spot5.position.set(0, 15, 0);
spot5.target = churchTarget;
spot5.castShadow = true;
scene.add(spot5);
lights.push({
    name: 'Holofote 5 (Topo)',
    light: spot5,
    color: 0xffffff,
    baseAngle: 0,
    colorIndex: 0,
    isTop: true
});

// Spotlight 6 - Lateral Esquerda (Ciano)
const spot6 = new THREE.SpotLight(0x00ffff, 40, 50, Math.PI / 5, 0.4, 1);
spot6.position.set(-12, 8, 0);
spot6.target = churchTarget;
spot6.castShadow = true;
scene.add(spot6);
lights.push({
    name: 'Holofote 6 (Lateral Esq)',
    light: spot6,
    color: 0x00ffff,
    baseAngle: Math.PI * 0.75,
    colorIndex: 1
});

// Spotlight 7 - Lateral Direita (Amarelo)
const spot7 = new THREE.SpotLight(0xffff00, 40, 50, Math.PI / 5, 0.4, 1);
spot7.position.set(12, 8, 0);
spot7.target = churchTarget;
spot7.castShadow = true;
scene.add(spot7);
lights.push({
    name: 'Holofote 7 (Lateral Dir)',
    light: spot7,
    color: 0xffff00,
    baseAngle: Math.PI * 1.25,
    colorIndex: 3
});

// Helpers visuais para os spotlights
lights.forEach((lightData, index) => {
    const helper = new THREE.SpotLightHelper(lightData.light, lightData.color);
    helper.visible = false; // Esconde por padr√£o para n√£o poluir a visualiza√ß√£o
    scene.add(helper);
    lightHelpers.push(helper);
});

// Fun√ß√£o para atualizar o show de luzes
function updateLightShow(time) {
    if (!lightShowConfig.enabled) return;

    const speed = lightShowConfig.speed;
    const colorSpeed = lightShowConfig.colorSpeed;

    lights.forEach((lightData, index) => {
        const light = lightData.light;

        // Anima√ß√£o de movimento (posi√ß√£o orbital)
        if (lightShowConfig.movementEnabled && !lightData.isTop) {
            const radius = 10;
            const height = 8 + Math.sin(time * speed + lightData.baseAngle) * 2;
            const angle = lightData.baseAngle + Math.sin(time * speed * 0.5) * 0.5;

            // Movimento suave orbital
            light.position.x = Math.cos(angle + time * speed * 0.3) * radius;
            light.position.z = Math.sin(angle + time * speed * 0.3) * radius;
            light.position.y = height;
        }

        // Anima√ß√£o de cor
        if (lightShowConfig.colorChangeEnabled) {
            const colorIndex = (lightData.colorIndex + Math.floor(time * colorSpeed)) % showColors.length;
            const nextColorIndex = (colorIndex + 1) % showColors.length;
            const t = (time * colorSpeed) % 1;

            // Interpola√ß√£o suave entre cores
            const currentColor = showColors[colorIndex];
            const nextColor = showColors[nextColorIndex];
            light.color.lerpColors(currentColor, nextColor, t);
        }

        // Pulsa√ß√£o de intensidade
        const baseIntensity = lightData.isTop ? 30 : 50;
        light.intensity = baseIntensity + Math.sin(time * speed * 2 + index) * 15;
    });

    // Atualiza helpers
    lightHelpers.forEach(helper => {
        if (helper.visible) helper.update();
    });
}

// ============================================
// T√âCNICA: Modo Dia/Noite
// Sistema de transi√ß√£o entre skyboxes diurno e noturno
// ============================================

const dayNightConfig = {
    mode: 'day', // 'day' ou 'night'
    transitionTime: 3.0, // Tempo de transi√ß√£o em segundos
    autoTransition: false, // Transi√ß√£o autom√°tica
    autoTransitionSpeed: 0.1 // Velocidade da transi√ß√£o autom√°tica
};

let dayNightBlend = 0.0; // 0 = dia, 1 = noite
let dayTexture = null;
let nightTexture = null;
let isTransitioning = false;

// Skybox - C√©u (ser√° carregado com texturas)
const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
let skyMaterial = new THREE.MeshBasicMaterial({
    color: 0x87ceeb,
    side: THREE.BackSide,
    fog: false
});
const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
scene.add(skybox);

// Carrega o skybox do dia (EXR)
const exrLoader = new EXRLoader();
exrLoader.load(
    '/public/skyboxes/qwantani_sunset_puresky_1k.exr',
    (texture) => {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        texture.colorSpace = THREE.LinearSRGBColorSpace;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        dayTexture = texture;

        // Se ainda n√£o temos a textura da noite, usa a do dia
        if (!nightTexture) {
            updateSkybox();
        }

        console.log('Skybox Dia carregado!');
    },
    undefined,
    (error) => {
        console.error('Erro ao carregar skybox dia:', error);
    }
);

// Carrega o skybox da noite (Gal√°xia) - usa o loader existente
const nightSkyboxLoader = new GLTFLoader();
nightSkyboxLoader.load(
    '/public/inside_galaxy_skybox_hdri_360_panorama/scene.gltf',
    (gltf) => {
        // Extrai a textura do modelo
        gltf.scene.traverse((child) => {
            if (child.isMesh && child.material) {
                if (child.material.map) {
                    const texture = child.material.map.clone();
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    texture.colorSpace = THREE.LinearSRGBColorSpace;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    nightTexture = texture;

                    updateSkybox();
                    console.log('Skybox Noite carregado!');
                }
            }
        });
    },
    undefined,
    (error) => {
        console.error('Erro ao carregar skybox noite:', error);
        // Se falhar, cria uma textura procedural escura
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#000011');
        gradient.addColorStop(0.5, '#000033');
        gradient.addColorStop(1, '#000000');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Adiciona estrelas
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 2;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        nightTexture = new THREE.CanvasTexture(canvas);
        nightTexture.mapping = THREE.EquirectangularReflectionMapping;
        nightTexture.colorSpace = THREE.LinearSRGBColorSpace;
        updateSkybox();
    }
);

// Fun√ß√£o para atualizar o skybox com blend entre dia e noite
function updateSkybox() {
    if (!dayTexture && !nightTexture) return;

    if (dayTexture && nightTexture) {
        // Usa shader customizado para blend entre as duas texturas
        const blendMaterial = new THREE.ShaderMaterial({
            uniforms: {
                dayTexture: { value: dayTexture },
                nightTexture: { value: nightTexture },
                blend: { value: dayNightBlend }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D dayTexture;
                uniform sampler2D nightTexture;
                uniform float blend;
                varying vec3 vWorldPosition;

                vec3 equirectangularUV(vec3 dir) {
                    float u = atan(dir.z, dir.x) / (2.0 * 3.14159265359) + 0.5;
                    float v = acos(dir.y) / 3.14159265359;
                    return vec3(u, v, 0.0);
                }

                void main() {
                    vec3 dir = normalize(vWorldPosition);
                    vec2 uv = equirectangularUV(dir).xy;
                    vec3 dayColor = texture2D(dayTexture, uv).rgb;
                    vec3 nightColor = texture2D(nightTexture, uv).rgb;
                    vec3 finalColor = mix(dayColor, nightColor, blend);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            side: THREE.BackSide,
            fog: false
        });
        skybox.material = blendMaterial;

        // Atualiza environment map (interpola entre os dois)
        if (dayNightBlend < 0.5) {
            scene.environment = dayTexture;
            scene.background = dayTexture;
        } else {
            scene.environment = nightTexture;
            scene.background = nightTexture;
        }
    } else if (dayTexture) {
        skyMaterial = new THREE.MeshBasicMaterial({
            map: dayTexture,
            side: THREE.BackSide,
            fog: false
        });
        skybox.material = skyMaterial;
        scene.environment = dayTexture;
        scene.background = dayTexture;
    } else if (nightTexture) {
        skyMaterial = new THREE.MeshBasicMaterial({
            map: nightTexture,
            side: THREE.BackSide,
            fog: false
        });
        skybox.material = skyMaterial;
        scene.environment = nightTexture;
        scene.background = nightTexture;
    }
}

// Fun√ß√£o para transicionar entre dia e noite
function transitionDayNight(targetMode, duration = null) {
    if (isTransitioning) return;

    const targetBlend = targetMode === 'night' ? 1.0 : 0.0;
    const transitionDuration = duration || dayNightConfig.transitionTime;
    const startBlend = dayNightBlend;
    const startTime = performance.now() * 0.001;

    isTransitioning = true;

    function animateTransition() {
        const currentTime = performance.now() * 0.001;
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / transitionDuration, 1.0);

        // Easing suave (ease in-out)
        const eased = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        dayNightBlend = startBlend + (targetBlend - startBlend) * eased;

        // Atualiza o skybox
        if (skybox.material.uniforms) {
            skybox.material.uniforms.blend.value = dayNightBlend;
        }

        // Atualiza fog e ambiente
        updateEnvironmentForDayNight();

        if (progress < 1.0) {
            requestAnimationFrame(animateTransition);
        } else {
            isTransitioning = false;
            dayNightConfig.mode = targetMode;
        }
    }

    animateTransition();
}

// Fun√ß√£o para atualizar ambiente (fog, luzes) conforme dia/noite
function updateEnvironmentForDayNight() {
    // Atualiza fog
    if (scene.fog && scene.fog.isFogExp2) {
        const dayFogColor = new THREE.Color(0x87ceeb); // Azul claro
        const nightFogColor = new THREE.Color(0x000033); // Azul escuro
        scene.fog.color.lerpColors(dayFogColor, nightFogColor, dayNightBlend);
        scene.fog.density = 0.015 + dayNightBlend * 0.01; // Mais denso √† noite
    }

    // Atualiza luz ambiente
    const dayAmbient = 0.1;
    const nightAmbient = 0.05;
    ambientLight.intensity = dayAmbient + (nightAmbient - dayAmbient) * dayNightBlend;

    // Atualiza luz de hemisf√©rio
    const daySkyColor = new THREE.Color(0x87ceeb);
    const nightSkyColor = new THREE.Color(0x000033);
    const dayGroundColor = new THREE.Color(0x4a7c59);
    const nightGroundColor = new THREE.Color(0x001122);

    hemisphereLight.color.lerpColors(daySkyColor, nightSkyColor, dayNightBlend);
    hemisphereLight.groundColor.lerpColors(dayGroundColor, nightGroundColor, dayNightBlend);
    hemisphereLight.intensity = 0.3 - dayNightBlend * 0.2; // Menos intenso √† noite
}

// Terreno - Base (mantido para sombras e f√≠sica)
const terrainSize = 50;
const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 128, 128); // Mais subdivis√µes para detalhe
const terrainMaterial = new THREE.MeshStandardMaterial({
    color: 0x4a7c59,
    roughness: 0.9,
    metalness: 0.1,
    visible: false // Invis√≠vel, apenas para f√≠sica
});
const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
terrain.rotation.x = -Math.PI / 2;
terrain.receiveShadow = true;
scene.add(terrain);

// Fun√ß√£o de ru√≠do simples para varia√ß√£o de terreno
function noise2D(x, z) {
    const X = Math.floor(x) & 255;
    const Z = Math.floor(z) & 255;
    x -= Math.floor(x);
    z -= Math.floor(z);
    const u = x * x * (3.0 - 2.0 * x);
    const v = z * z * (3.0 - 2.0 * z);

    // Hash function simples
    const A = (X + Z * 57) * 0.01;
    const B = ((X + 1) + Z * 57) * 0.01;
    const C = (X + (Z + 1) * 57) * 0.01;
    const D = ((X + 1) + (Z + 1) * 57) * 0.01;

    return (1.0 - v) * (1.0 - u) * Math.sin(A) +
           (1.0 - v) * u * Math.sin(B) +
           v * (1.0 - u) * Math.sin(C) +
           v * u * Math.sin(D);
}

// Fun√ß√£o de ru√≠do fractal (m√∫ltiplas camadas)
function fractalNoise(x, z, octaves = 4) {
    let value = 0;
    let amplitude = 1;
    let frequency = 0.1;
    let maxValue = 0;

    for (let i = 0; i < octaves; i++) {
        value += noise2D(x * frequency, z * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }

    return value / maxValue;
}

// Adiciona varia√ß√£o de altura ao terreno
const vertices = terrainGeometry.attributes.position;
const flatZoneRadius = 8; // Raio da zona plana ao redor da igreja
const maxHeight = 2.0; // Altura m√°xima do terreno

for (let i = 0; i < vertices.count; i++) {
    const x = vertices.getX(i);
    const z = vertices.getZ(i);

    // Dist√¢ncia do centro (onde a igreja est√°)
    const distanceFromCenter = Math.sqrt(x * x + z * z);

    // Fun√ß√£o que reduz a varia√ß√£o pr√≥ximo ao centro
    // Retorna 0 no centro e 1 nas bordas
    const heightFactor = Math.max(0, Math.min(1, (distanceFromCenter - flatZoneRadius) / (terrainSize / 2 - flatZoneRadius)));

    // Gera altura usando ru√≠do fractal
    const noiseValue = fractalNoise(x, z, 4);
    const height = noiseValue * maxHeight * heightFactor;

    // Adiciona pequenas varia√ß√µes locais
    const localVariation = (Math.random() - 0.5) * 0.2 * heightFactor;

    vertices.setY(i, height + localVariation);
}

terrainGeometry.computeVertexNormals();

// Fun√ß√£o para obter altura do terreno em uma posi√ß√£o (x, z)
function getTerrainHeight(x, z) {
    const distanceFromCenter = Math.sqrt(x * x + z * z);
    const flatZoneRadius = 8;
    const maxHeight = 2.0;

    const heightFactor = Math.max(0, Math.min(1, (distanceFromCenter - flatZoneRadius) / (terrainSize / 2 - flatZoneRadius)));
    const noiseValue = fractalNoise(x, z, 4);
    const height = noiseValue * maxHeight * heightFactor;

    return height;
}

// Sistema de Trilhas (GroundData)
class GroundData {
    constructor(size = 100) {
        this.size = size;
        this.trackCount = 4; // 4 trilhas (como 4 rodas, adaptado para pegadas)
        this.trackLength = 128;

        // DataTexture para cada trilha (128x1, RGBA)
        this.trackTextures = [];
        for (let i = 0; i < this.trackCount; i++) {
            const data = new Float32Array(this.trackLength * 4);
            const texture = new THREE.DataTexture(data, this.trackLength, 1, THREE.RGBAFormat, THREE.FloatType);
            texture.needsUpdate = true;
            this.trackTextures.push(texture);
        }

        // RenderTarget para o mapa de trilhas (aumenta resolu√ß√£o para √°rea maior)
        this.renderTarget = new THREE.WebGLRenderTarget(1024, 1024, {
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        });

        // Cena separada para renderizar trilhas
        this.trackScene = new THREE.Scene();
        this.trackCamera = new THREE.OrthographicCamera(-size/2, size/2, size/2, -size/2, 0.1, 100);
        this.trackCamera.position.set(0, 10, 0);
        this.trackCamera.lookAt(0, 0, 0);
    }

    addTrackPoint(trackIndex, position) {
        if (trackIndex >= this.trackCount) return;

        const texture = this.trackTextures[trackIndex];
        const data = texture.image.data;

        // Move todos os pontos uma posi√ß√£o √† direita
        for (let i = (this.trackLength - 1) * 4; i >= 4; i -= 4) {
            data[i] = data[i - 4];     // R = X
            data[i + 1] = data[i - 3]; // G = Y
            data[i + 2] = data[i - 2]; // Z
            data[i + 3] = data[i - 1]; // A
        }

        // Adiciona novo ponto no in√≠cio
        data[0] = position.x;
        data[1] = position.y;
        data[2] = position.z;
        data[3] = 1.0; // Alpha = 1 quando toca o solo

        texture.needsUpdate = true;
    }

    update(renderer) {
        // Renderiza as trilhas no RenderTarget
        renderer.setRenderTarget(this.renderTarget);
        renderer.render(this.trackScene, this.trackCamera);
        renderer.setRenderTarget(null);
    }

    getTrackTexture() {
        return this.renderTarget.texture;
    }
}

const groundData = new GroundData(100);

// Sistema de Grama Infinita
class InfiniteGrass {
    constructor(count = 50000, size = 50) {
        this.count = count;
        this.size = size;
        this.bladeSize = 0.3;
        this.grassGeometry = null;
        this.grassMaterial = null;
        this.grassMesh = null;
        this.centers = [];

        this.init();
    }

    init() {
        const positions = [];
        const centers = [];
        const ids = [];
        const heights = [];
        const widths = [];
        const indices = [];

        // Gera blades de grama em uma √°rea maior com margem de seguran√ßa
        const margin = this.size * 0.2; // 20% de margem extra
        const totalSize = this.size + margin * 2;

        for (let i = 0; i < this.count; i++) {
            // Gera em uma √°rea maior para garantir cobertura
            const x = (Math.random() - 0.5) * totalSize;
            const z = (Math.random() - 0.5) * totalSize;
            // Calcula a altura do terreno nesta posi√ß√£o
            const terrainHeight = getTerrainHeight(x, z);
            const center = new THREE.Vector3(x, terrainHeight, z);
            this.centers.push(center);

            const height = 0.3 + Math.random() * 0.2;
            const width = 0.02 + Math.random() * 0.01;

            // Cada blade √© um tri√¢ngulo simples (3 v√©rtices)
            const baseY = 0;
            const topY = height;

            // V√©rtice 1: base esquerda
            positions.push(-width, baseY, 0);
            centers.push(x, 0, z);
            ids.push(i);
            heights.push(height);
            widths.push(width);

            // V√©rtice 2: topo
            positions.push(0, topY, 0);
            centers.push(x, 0, z);
            ids.push(i);
            heights.push(height);
            widths.push(width);

            // V√©rtice 3: base direita
            positions.push(width, baseY, 0);
            centers.push(x, 0, z);
            ids.push(i);
            heights.push(height);
            widths.push(width);

            // √çndices do tri√¢ngulo
            const baseIndex = i * 3;
            indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
        }

        // Cria geometria
        this.grassGeometry = new THREE.BufferGeometry();
        this.grassGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        this.grassGeometry.setAttribute('center', new THREE.Float32BufferAttribute(centers, 3));
        this.grassGeometry.setAttribute('id', new THREE.Float32BufferAttribute(ids, 1));
        this.grassGeometry.setAttribute('height', new THREE.Float32BufferAttribute(heights, 1));
        this.grassGeometry.setAttribute('width', new THREE.Float32BufferAttribute(widths, 1));
        this.grassGeometry.setIndex(indices);

        // Carrega shaders inline (mais confi√°vel)
        this.loadDefaultShaders();
    }

    loadDefaultShaders() {
        // Shaders inline como fallback
        const vertexShader = `
            uniform float time;
            uniform vec3 uCameraPosition;
            uniform sampler2D trackTexture;
            attribute vec3 center;
            attribute float id;
            attribute float height;
            attribute float width;
            varying vec3 vColor;
            varying float vTipness;
            varying float vTrackInfluence;
            varying vec3 vNormal;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }

            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            vec3 getWind(vec2 pos, float time) {
                float windStrength = 0.15;
                float windFrequency1 = 0.5;
                float windFrequency2 = 1.5;
                vec2 windDirection = vec2(1.0, 0.0);
                vec2 windPos1 = pos * windFrequency1 + windDirection * time * 0.5;
                vec2 windPos2 = pos * windFrequency2 + windDirection * time * 0.3;
                float wind1 = noise(windPos1) * windStrength;
                float wind2 = noise(windPos2) * windStrength * 0.5;
                return vec3(wind1 + wind2, 0.0, 0.0);
            }

            void main() {
                vTipness = float(gl_VertexID % 3) / 2.0;
                vec3 localPos = position;
                vec3 wind = getWind(center.xz, time);
                localPos += wind * vTipness;
                vec3 toCamera = normalize(uCameraPosition - center);
                vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), toCamera));
                vec3 up = cross(toCamera, right);
                vec3 billboardPos = localPos.x * right + localPos.y * up;
                vec3 worldPos = center + billboardPos;
                vec2 trackUV = (worldPos.xz + 50.0) / 100.0;
                vec4 trackData = texture2D(trackTexture, trackUV);
                vTrackInfluence = trackData.a;
                float trackBend = vTrackInfluence * 0.3;
                worldPos.y -= trackBend * vTipness;
                float grassGreen = 0.3 + vTipness * 0.2;
                grassGreen -= vTrackInfluence * 0.1;
                vColor = vec3(0.1, grassGreen, 0.05);

                // Calcula normal para o fragment shader
                vNormal = normalize(normalMatrix * up);

                gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D matcapTexture;
            varying vec3 vColor;
            varying float vTipness;
            varying float vTrackInfluence;
            varying vec3 vNormal;

            void main() {
                vec3 grassColor = vColor;
                grassColor = mix(grassColor * 0.7, grassColor * 1.2, vTipness);
                grassColor *= (1.0 - vTrackInfluence * 0.3);

                // Usa a normal passada do vertex shader
                vec2 matcapUV = vNormal.xy * 0.5 + 0.5;
                vec3 matcap = texture2D(matcapTexture, matcapUV).rgb;
                vec3 finalColor = grassColor * (0.7 + matcap * 0.3);

                float alpha = 1.0;
                alpha *= (1.0 - vTrackInfluence * 0.5);
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // Cria MatCap texture
        const matcapSize = 256;
        const matcapData = new Uint8Array(matcapSize * matcapSize * 4);
        for (let i = 0; i < matcapSize * matcapSize; i++) {
            const x = (i % matcapSize) / matcapSize;
            const y = Math.floor(i / matcapSize) / matcapSize;
            const r = Math.sqrt((x - 0.5) ** 2 + (y - 0.5) ** 2);
            const intensity = Math.max(0, 1 - r * 2);
            matcapData[i * 4] = 128 + intensity * 127;
            matcapData[i * 4 + 1] = 128 + intensity * 127;
            matcapData[i * 4 + 2] = 128 + intensity * 127;
            matcapData[i * 4 + 3] = 255;
        }
        const matcapTexture = new THREE.DataTexture(matcapData, matcapSize, matcapSize, THREE.RGBAFormat);
        matcapTexture.needsUpdate = true;

        this.grassMaterial = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                time: { value: 0 },
                uCameraPosition: { value: camera.position },
                trackTexture: { value: groundData.getTrackTexture() },
                grassDensity: { value: 1.0 },
                windDirection: { value: new THREE.Vector2(1, 0) },
                matcapTexture: { value: matcapTexture }
            },
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.1
        });

        this.grassMesh = new THREE.Mesh(this.grassGeometry, this.grassMaterial);
        this.grassMesh.frustumCulled = false;
        scene.add(this.grassMesh);
    }

    update(time, cameraPos) {
        if (this.grassMaterial) {
            this.grassMaterial.uniforms.time.value = time;
            this.grassMaterial.uniforms.uCameraPosition.value.copy(cameraPos);
            this.grassMaterial.uniforms.trackTexture.value = groundData.getTrackTexture();

            // Reposiciona blades que sa√≠ram dos limites (infinite tiling)
            // Usa uma √°rea maior para garantir cobertura cont√≠nua
            const margin = this.size * 0.2;
            const halfSize = (this.size + margin * 2) / 2;
            const tileSize = this.size + margin * 2;

            this.centers.forEach((center, i) => {
                const dx = cameraPos.x - center.x;
                const dz = cameraPos.z - center.z;

                // Reposiciona quando sai da √°rea vis√≠vel
                if (Math.abs(dx) > halfSize) {
                    const offset = Math.sign(dx) * tileSize;
                    center.x += offset;
                    // Atualiza altura do terreno na nova posi√ß√£o
                    center.y = getTerrainHeight(center.x, center.z);
                }
                if (Math.abs(dz) > halfSize) {
                    const offset = Math.sign(dz) * tileSize;
                    center.z += offset;
                    // Atualiza altura do terreno na nova posi√ß√£o
                    center.y = getTerrainHeight(center.x, center.z);
                }

                // Atualiza atributos
                const baseIndex = i * 3;
                for (let j = 0; j < 3; j++) {
                    this.grassGeometry.attributes.center.setXYZ(baseIndex + j, center.x, center.y, center.z);
                }
            });
            this.grassGeometry.attributes.center.needsUpdate = true;
        }
    }
}

// Aumenta a √°rea de grama para cobrir mais espa√ßo e adiciona mais blades
const infiniteGrass = new InfiniteGrass(100000, 100);

// Caminho de pedras em frente √† igreja
const pathGroup = new THREE.Group();
const pathMaterial = new THREE.MeshStandardMaterial({
    color: 0x6b6b6b, // Cinza pedra
    roughness: 0.8,
    metalness: 0.1
});

// Cria v√°rias pedras para o caminho
for (let i = 0; i < 8; i++) {
    const stoneSize = 0.8 + Math.random() * 0.4;
    const stoneGeometry = new THREE.BoxGeometry(
        stoneSize,
        0.1,
        stoneSize * (0.7 + Math.random() * 0.3)
    );
    const stone = new THREE.Mesh(stoneGeometry, pathMaterial);
    stone.position.set(
        (i - 3.5) * 1.2 - 5,
        0.05,
        -2 + Math.random() * 0.3 + 9.5
    );
    stone.rotation.y = Math.random() * Math.PI * 0.2;
    stone.receiveShadow = true;
    pathGroup.add(stone);
}
scene.add(pathGroup);

// Pedras decorativas ao redor
const decorativeStones = new THREE.Group();
for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    const radius = 8 + Math.random() * 4;
    const stoneSize = 0.3 + Math.random() * 0.2;

    const stoneGeometry = new THREE.DodecahedronGeometry(stoneSize, 0);
    const stoneMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(0.1, 0.2, 0.3 + Math.random() * 0.2),
        roughness: 0.9,
        metalness: 0.1
    });
    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);

    stone.position.set(
        Math.cos(angle) * radius,
        stoneSize * 0.5,
        Math.sin(angle) * radius
    );
    stone.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
    );
    stone.castShadow = true;
    stone.receiveShadow = true;
    decorativeStones.add(stone);
}
scene.add(decorativeStones);

// √Årvores simples ao redor da igreja
const treesGroup = new THREE.Group();

// Fun√ß√£o para criar uma √°rvore simples
function createTree(x, z, scale = 1) {
    const tree = new THREE.Group();

    // Tronco
    const trunkGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 1.5 * scale, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({
        color: 0x5d4037, // Marrom
        roughness: 0.9,
        metalness: 0.1
    });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.y = 0.75 * scale;
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    tree.add(trunk);

    // Folhas (copa)
    const leavesGeometry = new THREE.ConeGeometry(1 * scale, 2 * scale, 8);
    const leavesMaterial = new THREE.MeshStandardMaterial({
        color: 0x2d5016, // Verde escuro
        roughness: 0.8,
        metalness: 0.1
    });
    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
    leaves.position.y = 2 * scale;
    leaves.castShadow = true;
    leaves.receiveShadow = true;
    tree.add(leaves);

    tree.position.set(x, 0, z);
    return tree;
}

// Adiciona √°rvores em posi√ß√µes estrat√©gicas
const treePositions = [
    { x: -12, z: -8, scale: 1.2 },
    { x: 12, z: -8, scale: 1.0 },
    { x: -10, z: 10, scale: 0.9 },
    { x: 10, z: 10, scale: 1.1 },
    { x: -15, z: 0, scale: 1.0 },
    { x: 15, z: 0, scale: 0.8 }
];

treePositions.forEach(pos => {
    const tree = createTree(pos.x, pos.z, pos.scale);
    treesGroup.add(tree);
});

scene.add(treesGroup);

// Vari√°vel para armazenar o modelo
let model = null;
let modelPosition = { x: 0, y: 0, z: 0 };
let modelRotation = { x: 0, y: 0, z: 0 };
let modelScale = { x: 1, y: 1, z: 1 };

// Loader para modelos GLTF
const loader = new GLTFLoader();

// Elemento de loading
const loadingElement = document.getElementById('loading');

// ============================================
// T√âCNICA: Multi-Textura
// Cria texturas procedurais de detalhes (sujeira, musgo) para combinar com texturas base
// ============================================

// Fun√ß√£o para criar textura de detalhes procedurais (sujeira/musgo)
function createDetailTexture(size = 512) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Base verde musgo
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, 'rgba(50, 100, 30, 0)');
    gradient.addColorStop(0.3, 'rgba(60, 120, 40, 0.3)');
    gradient.addColorStop(0.7, 'rgba(40, 80, 25, 0.2)');
    gradient.addColorStop(1, 'rgba(30, 60, 20, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Adiciona manchas de sujeira
    for (let i = 0; i < 50; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const radius = 20 + Math.random() * 40;
        const alpha = 0.1 + Math.random() * 0.2;

        const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
        grd.addColorStop(0, `rgba(30, 20, 10, ${alpha})`);
        grd.addColorStop(1, 'rgba(30, 20, 10, 0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Adiciona padr√µes de musgo (manchas verdes)
    for (let i = 0; i < 30; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const radius = 15 + Math.random() * 25;
        const alpha = 0.15 + Math.random() * 0.25;

        const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
        grd.addColorStop(0, `rgba(50, 100, 30, ${alpha})`);
        grd.addColorStop(0.5, `rgba(40, 80, 25, ${alpha * 0.5})`);
        grd.addColorStop(1, 'rgba(30, 60, 20, 0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 2); // Repete a textura
    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    return texture;
}

// Cria textura de detalhes
const detailTexture = createDetailTexture(512);

// ============================================
// T√âCNICA: Environment Mapping (CubeMap)
// Cria um cubemap para reflex√µes realistas
// ============================================

// Vari√°vel para armazenar configura√ß√µes de multi-textura e environment mapping
const textureConfig = {
    multiTextureEnabled: true,
    envMapIntensity: 0.5
};

// Carrega o modelo
loadingElement.classList.add('show');
loader.load(
    '/public/models/stylized_gothic_church/scene.gltf',
    (gltf) => {
        model = gltf.scene;

        // Habilita sombras e ajusta materiais para responder √† ilumina√ß√£o
        model.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;

                // Garante que os materiais respondam √† ilumina√ß√£o
                if (child.material) {
                    // Fun√ß√£o auxiliar para aplicar multi-textura e environment mapping
                    const applyAdvancedTexturing = (mat) => {
                        // Converte para MeshPhysicalMaterial para suportar environment mapping
                        if (!mat.isMeshPhysicalMaterial) {
                            const oldMat = mat;
                            const newMat = new THREE.MeshPhysicalMaterial({
                                color: oldMat.color,
                                map: oldMat.map,
                                normalMap: oldMat.normalMap,
                                roughnessMap: oldMat.roughnessMap,
                                metalnessMap: oldMat.metalnessMap,
                                aoMap: oldMat.aoMap,
                                emissiveMap: oldMat.emissiveMap,
                                transparent: oldMat.transparent,
                                opacity: oldMat.opacity,
                                side: oldMat.side,
                                roughness: oldMat.roughness !== undefined ? oldMat.roughness : 0.7,
                                metalness: oldMat.metalness !== undefined ? oldMat.metalness : 0.1
                            });

                            // Multi-Textura: adiciona textura de detalhes
                            if (textureConfig.multiTextureEnabled) {
                                newMat.aoMap = detailTexture; // Usa como AO map para detalhes
                            }

                            // Environment Mapping: usa o environment map da cena
                            if (scene.environment) {
                                newMat.envMap = scene.environment;
                                newMat.envMapIntensity = textureConfig.envMapIntensity;
                            }

                            return newMat;
                        } else {
                            // J√° √© MeshPhysicalMaterial, apenas adiciona as texturas
                            if (textureConfig.multiTextureEnabled) {
                                mat.aoMap = detailTexture;
                            }
                            if (scene.environment) {
                                mat.envMap = scene.environment;
                                mat.envMapIntensity = textureConfig.envMapIntensity;
                            }
                            return mat;
                        }
                    };

                    // Se for um array de materiais
                    if (Array.isArray(child.material)) {
                        child.material = child.material.map((mat, index) => {
                            // Converte MeshBasicMaterial para MeshStandardMaterial primeiro
                            if (mat.type === 'MeshBasicMaterial') {
                                const newMaterial = new THREE.MeshStandardMaterial({
                                    color: mat.color,
                                    map: mat.map,
                                    normalMap: mat.normalMap,
                                    roughnessMap: mat.roughnessMap,
                                    metalnessMap: mat.metalnessMap,
                                    aoMap: mat.aoMap,
                                    emissiveMap: mat.emissiveMap,
                                    transparent: mat.transparent,
                                    opacity: mat.opacity,
                                    side: mat.side
                                });
                                return applyAdvancedTexturing(newMaterial);
                            } else {
                                return applyAdvancedTexturing(mat);
                            }
                        });
                    } else {
                        // Material √∫nico
                        if (child.material.type === 'MeshBasicMaterial') {
                            const oldMat = child.material;
                            const newMaterial = new THREE.MeshStandardMaterial({
                                color: oldMat.color,
                                map: oldMat.map,
                                normalMap: oldMat.normalMap,
                                roughnessMap: oldMat.roughnessMap,
                                metalnessMap: oldMat.metalnessMap,
                                aoMap: oldMat.aoMap,
                                emissiveMap: oldMat.emissiveMap,
                                transparent: oldMat.transparent,
                                opacity: oldMat.opacity,
                                side: oldMat.side
                            });
                            child.material = applyAdvancedTexturing(newMaterial);
                        } else {
                            child.material = applyAdvancedTexturing(child.material);
                        }
                    }

                    // Aplica filtro anisotr√≥pico em todas as texturas
                    const applyAnisotropy = (mat) => {
                        if (mat.map) mat.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        if (mat.normalMap) mat.normalMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        if (mat.roughnessMap) mat.roughnessMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        if (mat.metalnessMap) mat.metalnessMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        if (mat.aoMap) mat.aoMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    };

                    if (Array.isArray(child.material)) {
                        child.material.forEach(applyAnisotropy);
                    } else {
                        applyAnisotropy(child.material);
                    }
                }
            }
        });

        // Calcula o bounding box para centralizar o modelo
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // Centraliza o modelo
        model.position.x = 0;
        model.position.y = 0;
        model.position.z = 0;

        // Atualiza as vari√°veis de posi√ß√£o
        modelPosition.x = model.position.x;
        modelPosition.y = model.position.y;
        modelPosition.z = model.position.z;

        // Ajusta a c√¢mera para focar no modelo
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.5; // Adiciona um pouco de espa√ßo

        camera.position.set(cameraZ, cameraZ * 0.5, cameraZ);
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
        controls.update();

        // Adiciona o modelo √† cena
        scene.add(model);

        // Esconde o loading
        loadingElement.classList.remove('show');

        // Inicializa a GUI ap√≥s o modelo carregar
        initGUI();

        console.log('Modelo carregado com sucesso!');
    },
    (progress) => {
        const percent = (progress.loaded / progress.total * 100).toFixed(0);
        loadingElement.textContent = `Carregando modelo... ${percent}%`;
        console.log('Carregando modelo...', percent + '%');
    },
    (error) => {
        loadingElement.textContent = 'Erro ao carregar modelo!';
        console.error('Erro ao carregar modelo:', error);
    }
);

// Grid helper
const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc);
scene.add(gridHelper);

// Axes helper (opcional - mostra os eixos X, Y, Z)
const axesHelper = new THREE.AxesHelper(2);
scene.add(axesHelper);

// Configura√ß√µes para a GUI
const guiConfig = {
    // C√¢mera
    camera: {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        fov: camera.fov
    },
    // Ambiente
    ambiente: {
        cor: '#000000',
        intensidade: ambientLight.intensity
    }
};

// Fun√ß√£o para inicializar a GUI
function initGUI() {
    const gui = new GUI({ title: 'Controles da Cena' });
    // Controles do Show de Luzes
    const lightsFolder = gui.addFolder('üéÜ Show de Luzes');
    lightsFolder.add(lightShowConfig, 'enabled').name('Ativar Show');
    lightsFolder.add(lightShowConfig, 'speed', 0.1, 3, 0.1).name('Velocidade');
    lightsFolder.add(lightShowConfig, 'colorSpeed', 0.1, 2, 0.1).name('Velocidade Cores');
    lightsFolder.add(lightShowConfig, 'movementEnabled').name('Movimento');
    lightsFolder.add(lightShowConfig, 'colorChangeEnabled').name('Mudan√ßa de Cor');
    lightsFolder.add({
        mostrarHelpers: false
    }, 'mostrarHelpers').name('Mostrar Helpers').onChange((value) => {
        lightHelpers.forEach(helper => {
            helper.visible = value;
        });
    });
    lightsFolder.open();

    // Controles individuais dos holofotes
    const spotsFolder = gui.addFolder('Holofotes Individuais');
    lights.forEach((lightData, index) => {
        const lightFolder = spotsFolder.addFolder(lightData.name);
        lightFolder.add(lightData.light, 'intensity', 0, 100, 1).name('Intensidade');
        lightFolder.add(lightData.light, 'angle', 0.1, Math.PI / 2, 0.01).name('√Çngulo');
        lightFolder.add(lightData.light, 'penumbra', 0, 1, 0.1).name('Penumbra');
        lightFolder.add(lightData.light, 'distance', 10, 100, 5).name('Dist√¢ncia');
        lightFolder.add(lightData.light, 'visible').name('Vis√≠vel');
    });

    // Controles da C√¢mera
    const cameraFolder = gui.addFolder('C√¢mera');
    cameraFolder.add(guiConfig.camera, 'x', -50, 50, 0.5).name('Posi√ß√£o X').onChange((value) => {
        camera.position.x = value;
        controls.update();
    });
    cameraFolder.add(guiConfig.camera, 'y', 0, 50, 0.5).name('Posi√ß√£o Y').onChange((value) => {
        camera.position.y = value;
        controls.update();
    });
    cameraFolder.add(guiConfig.camera, 'z', -50, 50, 0.5).name('Posi√ß√£o Z').onChange((value) => {
        camera.position.z = value;
        controls.update();
    });
    cameraFolder.add(guiConfig.camera, 'fov', 10, 120, 1).name('Campo de Vis√£o').onChange((value) => {
        camera.fov = value;
        camera.updateProjectionMatrix();
    });

    // Controles do Ambiente
    const ambienteFolder = gui.addFolder('Ambiente');
    ambienteFolder.add(guiConfig.ambiente, 'intensidade', 0, 2, 0.1).name('Luz Ambiente Intensidade').onChange((value) => {
        ambientLight.intensity = value;
    });
    ambienteFolder.addColor(guiConfig.ambiente, 'cor').name('Luz Ambiente Cor').onChange((value) => {
        ambientLight.color.setHex(value);
    });

    // Controles de Fog (Neblina)
    const fogConfig = {
        habilitado: true,
        cor: 0x87ceeb,
        densidade: 0.015
    };
    ambienteFolder.add(fogConfig, 'habilitado').name('Fog Habilitado').onChange((value) => {
        if (value) {
            scene.fog = new THREE.FogExp2(fogConfig.cor, fogConfig.densidade);
        } else {
            scene.fog = null;
        }
    });
    ambienteFolder.addColor(fogConfig, 'cor').name('Cor do Fog').onChange((value) => {
        if (scene.fog && scene.fog.isFogExp2) {
            scene.fog.color.setHex(value);
            fogConfig.cor = value;
        }
    });
    ambienteFolder.add(fogConfig, 'densidade', 0, 0.1, 0.001).name('Densidade do Fog').onChange((value) => {
        if (scene.fog && scene.fog.isFogExp2) {
            scene.fog.density = value;
        }
    });

    // Controles da Luz de Hemisf√©rio
    const hemisphereFolder = gui.addFolder('Luz de Hemisf√©rio');
    const hemisphereConfig = {
        intensidade: hemisphereLight.intensity,
        corCeu: '#87ceeb',
        corSolo: '#4a7c59'
    };
    hemisphereFolder.add(hemisphereConfig, 'intensidade', 0, 2, 0.1).name('Intensidade').onChange((value) => {
        hemisphereLight.intensity = value;
    });
    hemisphereFolder.addColor(hemisphereConfig, 'corCeu').name('Cor do C√©u').onChange((value) => {
        hemisphereLight.color.setHex(value);
    });
    hemisphereFolder.addColor(hemisphereConfig, 'corSolo').name('Cor do Solo').onChange((value) => {
        hemisphereLight.groundColor.setHex(value);
    });
    hemisphereFolder.add(hemisphereLight, 'visible').name('Vis√≠vel');

    // Controles do Terreno
    const terrainFolder = gui.addFolder('Terreno');
    terrainFolder.add(terrain, 'visible').name('Mostrar Base (F√≠sica)');

    // Controles da Grama Infinita
    const grassFolder = gui.addFolder('Grama Infinita');
    if (infiniteGrass && infiniteGrass.grassMesh) {
        grassFolder.add(infiniteGrass.grassMesh, 'visible').name('Vis√≠vel');
        if (infiniteGrass.grassMaterial) {
            grassFolder.add(infiniteGrass.grassMaterial.uniforms.grassDensity, 'value', 0.1, 2.0, 0.1).name('Densidade');
            grassFolder.add(infiniteGrass.grassMaterial.uniforms.windDirection.value, 'x', -2, 2, 0.1).name('Dire√ß√£o Vento X');
            grassFolder.add(infiniteGrass.grassMaterial.uniforms.windDirection.value, 'y', -2, 2, 0.1).name('Dire√ß√£o Vento Z');
        }
    }

    // Controles de Trilhas
    const tracksFolder = gui.addFolder('Trilhas');
    tracksFolder.add({
        limparTrilhas: () => {
            for (let i = 0; i < groundData.trackCount; i++) {
                const data = groundData.trackTextures[i].image.data;
                data.fill(0);
                groundData.trackTextures[i].needsUpdate = true;
            }
        }
    }, 'limparTrilhas').name('Limpar Trilhas');

    // Controles do Caminho
    const pathFolder = gui.addFolder('Caminho');
    const pathColor = { cor: 0x6b6b6b };
    pathFolder.addColor(pathColor, 'cor').name('Cor das Pedras').onChange((value) => {
        pathMaterial.color.setHex(value);
    });
    pathFolder.add(pathGroup, 'visible').name('Vis√≠vel');

    // Controles das Pedras Decorativas
    const stonesFolder = gui.addFolder('Pedras Decorativas');
    stonesFolder.add(decorativeStones, 'visible').name('Vis√≠vel');

    // Controles das √Årvores
    const treesFolder = gui.addFolder('√Årvores');
    treesFolder.add(treesGroup, 'visible').name('Vis√≠vel');

    // Controles de Multi-Textura e Environment Mapping
    const textureFolder = gui.addFolder('Texturas Avan√ßadas');
    textureFolder.add(textureConfig, 'multiTextureEnabled').name('Multi-Textura (Detalhes)').onChange((value) => {
        if (model) {
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        if (value) {
                            mat.aoMap = detailTexture;
                        } else {
                            mat.aoMap = null;
                        }
                        mat.needsUpdate = true;
                    });
                }
            });
        }
    });
    textureFolder.add(textureConfig, 'envMapIntensity', 0, 2, 0.1).name('Intensidade EnvMap').onChange((value) => {
        if (model) {
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        if (mat.isMeshPhysicalMaterial) {
                            mat.envMapIntensity = value;
                        }
                    });
                }
            });
        }
    });

    // Controles da Cena
    const sceneFolder = gui.addFolder('Cena');
    const bgColor = { cor: 0x000000 };
    sceneFolder.addColor(bgColor, 'cor').name('Cor de Fundo').onChange((value) => {
        scene.background = new THREE.Color(value);
    });

    // Controles de Dia/Noite
    const dayNightFolder = gui.addFolder('üåÖ Modo Dia/Noite');
    dayNightFolder.add(dayNightConfig, 'mode', ['day', 'night']).name('Modo').onChange((value) => {
        transitionDayNight(value);
    });
    dayNightFolder.add(dayNightConfig, 'transitionTime', 0.5, 10, 0.5).name('Tempo Transi√ß√£o (s)');
    dayNightFolder.add(dayNightConfig, 'autoTransition').name('Transi√ß√£o Autom√°tica');
    dayNightFolder.add(dayNightConfig, 'autoTransitionSpeed', 0.01, 0.5, 0.01).name('Velocidade Auto');
    dayNightFolder.add({
        irParaDia: () => transitionDayNight('day')
    }, 'irParaDia').name('‚û°Ô∏è Ir para Dia');
    dayNightFolder.add({
        irParaNoite: () => transitionDayNight('night')
    }, 'irParaNoite').name('‚û°Ô∏è Ir para Noite');
    dayNightFolder.open();

    sceneFolder.add(skybox, 'visible').name('Mostrar Skybox');

    sceneFolder.add(gridHelper, 'visible').name('Mostrar Grid');
    sceneFolder.add(axesHelper, 'visible').name('Mostrar Eixos');

    // Fun√ß√£o para resetar c√¢mera
    sceneFolder.add({
        resetCamera: () => {
            if (model) {
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5;
                camera.position.set(cameraZ, cameraZ * 0.5, cameraZ);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
                guiConfig.camera.x = camera.position.x;
                guiConfig.camera.y = camera.position.y;
                guiConfig.camera.z = camera.position.z;
                cameraFolder.updateDisplay();
            }
        }
    }, 'resetCamera').name('Resetar C√¢mera');

    // Fun√ß√£o para resetar modelo
    sceneFolder.add({
        resetModel: () => {
            if (model) {
                model.position.x = 0;
                model.position.y = 0;
                model.position.z = 0;
            }
        }
    }, 'resetModel').name('Resetar Modelo');
}

// Vari√°vel para rastrear posi√ß√£o anterior da c√¢mera (para criar trilhas)
let lastCameraPosition = new THREE.Vector3();
let trackCounter = 0;

// Anima√ß√£o
function animate() {
    requestAnimationFrame(animate);

    const time = performance.now() * 0.001;

    // Atualiza os controles
    controls.update();

    // Atualiza o show de luzes
    updateLightShow(time);

    // Cria trilhas baseadas no movimento da c√¢mera (simula pegadas)
    const cameraPos = camera.position.clone();
    cameraPos.y = 0; // Projeta no ch√£o

    if (lastCameraPosition.distanceTo(cameraPos) > 0.5) {
        // Adiciona ponto de trilha a cada 0.5 unidades de movimento
        for (let i = 0; i < 4; i++) {
            const offset = new THREE.Vector3(
                (i % 2 - 0.5) * 0.3, // Offset lateral
                0,
                Math.floor(i / 2) * 0.2 // Offset frontal
            );
            const trackPos = cameraPos.clone().add(offset);
            groundData.addTrackPoint(i, trackPos);
        }
        lastCameraPosition.copy(cameraPos);
    }

    // Atualiza o sistema de trilhas
    groundData.update(renderer);

    // Atualiza a grama infinita
    if (infiniteGrass) {
        infiniteGrass.update(time, camera.position);
    }

    // Atualiza transi√ß√£o autom√°tica dia/noite
    if (dayNightConfig.autoTransition && !isTransitioning) {
        dayNightBlend = (Math.sin(time * dayNightConfig.autoTransitionSpeed) + 1) / 2;
        if (skybox.material.uniforms) {
            skybox.material.uniforms.blend.value = dayNightBlend;
        }
        updateEnvironmentForDayNight();
    }

    // Renderiza a cena
    renderer.render(scene, camera);
}

// Ajusta o tamanho quando a janela √© redimensionada
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Inicia a anima√ß√£o
animate();
